---
layout: post 
comments: true
title: "[Webinar Recording] Design Patterns: Not Just for Architects"
date: 2017-03-23 13:22:00 +01:00
categories: [Webinars]
permalink: /post/webinar-recording-design-patterns-jeremy-clark.html
author: "Iveta Moldavcuk"
---
<p>Design patterns are not just for architects. In fact, you already use Design Patterns but probably don&rsquo;t know it. Observer, Proxy, Facade - these are patterns that allow us to better communicate our ideas with other developers. And once we understand the patterns, we can use solutions that people way smarter than us have already implemented.</p>
<p>In this session, Jeremy Clark takes a look at several Gang of Four patterns that we regularly use without realizing it. Don&rsquo;t know who the Gang of Four is? Watch the webinar to find out.</p>
<p>Watch the webinar and learn:</p>
<ul>
<li>What design patterns are (and what they are not)</li>
<li>How design patterns offer solutions to common problems</li>
<li>How we already use many design patterns, including Observer, Proxy, and Facade</li>
<li>How our modern languages support design patterns</li>
</ul>
<p><iframe src="https://player.vimeo.com/video/209713477" frameborder="0" width="500" height="375"></iframe></p>
<p><a href="https://vimeo.com/209713477">Design Patterns: Not Just for Architects</a> on <a href="https://vimeo.com">Vimeo</a>.</p>
<p><a href="http://bit.ly/jeremy-clark-github">Download code samples</a>.</p>
<h2>Video Content</h2>
<ol>
<li>&nbsp;What Are Design Patterns? (3:33)</li>
<li>&nbsp;The Gang Of Four Book (5:29)</li>
<li>&nbsp;Anatomy of a Design Pattern (7:09)</li>
<li>&nbsp;The Gang of Four Patterns and Categories (10:31)</li>
<li>&nbsp;The Book Head First Design Patterns (12:49)</li>
<li>&nbsp;Why Care about Design Patterns? (15:33)</li>
<li>&nbsp;Observer Pattern (20:28)</li>
<li>&nbsp;Proxy Pattern (31:18)</li>
<li>&nbsp;Facade Pattern (40:39)</li>
<li>&nbsp;Summary (47:42)</li>
<li>&nbsp;Q&amp;A (49:39)</li>
</ol>
<h2>Webinar Transcript</h2>
<h3>Introduction</h3>
<p>Alex:</p>
<p>Hello everyone and welcome to today's webinar, Design Patterns Not Just for Architects. My name is Alex and I'll be your moderator. I work as a software developer here at PostSharp. I'm excited to be hosting this session today. I'm pleased to introduce today's speaker, Jeremy Clark. Jeremy is Microsoft MVP for .NET and a Pluralsight author. Today, he's going to show you how modern languages support design patterns.</p>
<p>Before I hand the mic over to Jeremy, I have a few housekeeping items to cover about this presentation. First of all, this webinar is brought to you by PostSharp. PostSharp is an extension that adds support patterns to C# and VB. If you're tired of repeating yourself in your code, you may want to check it out as did folks in Microsoft, Intel, Bank of America who have been using PostSharp who have been using PostSharp in their projects development and maintenance time.</p>
<p>Customers typically cut down their code base by 15% by using our product. So, feel free to visit our website, www.postsharp.net, for more details and to get a free trial. Next, today's webinar is being recorded and the recording will available after the live session. You'll receive an email with the recording link.</p>
<p>The last thing is we'd love to hear from you during today's presentation. So, please if you have a question for our speaker, feel free to send it through question window at the bottom of your player. We'll be answering the questions at the end of the session. If we don't get to your question, we'll be sure to follow up later afterwards. Without any other further ado, I'd like to kick things off by welcoming Jeremy Clark. Jeremy, now it's over to you.</p>
<p>Jeremy:</p>
<p>Thanks, Alex. Today, I am going to talk about design patterns. The reason for this is I always thought that designs patterns were one of those things that were just for architects, but I found out that they're extremely useful to everyday developers as well. My eye opening experience was when I was working at corporate developer, I worked on a really awesome team.</p>
<p>The developer who sat next to me, he had 10 years of experience on me as far as being in the industry. One day he just pops up out of his desk and he's really excited. He says, "I've been using the facade pattern without even realizing it." I thought well, that's kind of cool but it's also a problem because that means that we've been using something accidentally rather than using it intentionally.</p>
<p>What I found is that, in looking at patterns, once I start to recognize the problems that they're trying to solve, now I can associate that with the design pattern, it leads me to a solution that I can look up implementations online and I can create my own implementations if that makes sense. That's really why I started getting into the design patterns world.</p>
<p>Now as Alex mentioned, I am a Pluralsight author and if you do want to dig into the topic a little more, I do have a course on Pluralsight called <a href="https://www.pluralsight.com/courses/design-patterns-on-ramp" target="_blank">Design Patterns On-Ramp</a>. It talks about some of the things I'll be talking about today, but it's also about three and a half hours long. So, there's a lot more material than I have time to cover.</p>
<p>If you're not familiar with Pluralsight, really awesome online training. If you learn well by video, I would highly, highly recommend it. I'll have a link to this at the end of the slides as well. But with that said, let's go ahead and get started talking about design patterns themselves.</p>
<h3>What Are Design Patterns?</h3>
<p>Now, I really hate putting big blocks of text up on the screen, but in this case, this is the definition that has entered our industry as far as what design patterns are. Each pattern describes a problem that occurs over and over again in our environment and as programmers we should recognize that.</p>
<p>There's times where I need to get notified when a state changes. There's times where I have to be able to create three different objects and inject parameters into them. There's times where I might say, you know what, I need to pass the message along between different objects. These are problems that occur over and over in our environment.</p>
<p>Now design patterns, after they describe the problem, they then describe the core of the solution to the problem. So, design patterns aren't actually telling us here is the code you need to write. They're saying here's the ideas behind it and it's actually up to us to implement that idea. In fact, if we continue with this definition, they describe the core of the solution to the problem in such a way that you can use the solution a million times over without ever doing it the same way twice.</p>
<p>Now, obviously that's not something we would normally recommend because we don't want to reinvent the wheel, but there are different kinds of wheels that you can choose from. Now, the really interesting thing about this particular definition that comes from Christopher Alexander is that it has absolutely nothing to do with software. Christopher Alexander was actually talking about architecture, like real architecture with buildings, and bridges and things like that. Now, it turns out that this definition did apply very well to the software environment and so that's why we picked up on it.</p>
<h3>The Gang of Four&nbsp;</h3>
<p>Now, there were some, I would say, really smart people who thought about this and they created this book, which you might have heard of. It's that infamous Design Patterns book, Elements of Reusable Object-Oriented Software. If you've ever heard the term Gang of Four, this is what we're talking about. This is the Gang of Four book. Usually we call it that because it was written by four different authors and it's easier to say Gang of Four than try to list out all their names.</p>
<p>The Gang of Four book is one of those books that every developer has to have on their shelf because it makes you look really, really smart. The problem with the book is it's pretty academic and so it's a little bit difficult to read. So, you might say, "I don't know about this. Are design patterns important?" The answer is yes they are, definitely. This particular book described 23 patterns.</p>
<p>The reason why this became so important in our industry is because this was the first design pattern catalog. Now there's way more than 23 patterns now. There's hundreds and probably thousands of them out there, but this was again the starting point. This book was written way, way back in 1994. If you think about that, it's like what is that in computer years? That would be like 300 computer years. So, we start to question, are they still relevant? Again, the answer is yes and we'll see why as we go along today.</p>
<h3>Anatomy of a Design Pattern</h3>
<p>Now the Gang of Four, since they were kind of the first ones doing this, they were able to describe what does a pattern actually consist of. There's four basic elements and this again is something that has moved on to other pattern descriptions through the years.</p>
<p>The first one is the <strong>pattern name</strong>. So, this is a unique way of referring to the pattern. Hopefully, it's something that describes either what the pattern does or the problem it's trying to solve. It also is not something that would be ambiguous in our industry. Now since the Gang of Four were kind of the first ones out there, they got to pick some pretty simple names, things like bridge and observer and adaptor.</p>
<p>The patterns that are coming up after that, a lot of times we have to have a little bit longer names to keep them unambiguous. So, we end up with cool names like MVC, Model&ndash;view&ndash;controller or MVVM, Model&ndash;view&ndash;viewmodel, or IOC, Inversion of Control. A lot of times the pattern names that have come after that had to have been a little bit more descriptive just because all of the easy names were taken.</p>
<p>In addition to the pattern name, obviously the pattern has to describe the <strong>problem</strong> that it's trying to solve. Again, this is that thing that occurs over and over again in our environment. We'll be looking at some examples of this as we go along.</p>
<p>The third thing is the <strong>solution</strong> to the problem. Again, this is the core of that solution. It doesn't give a specific implementation. Now it turns out that most pattern catalogs will provide some code for us to look at because of course we're programmers and it's easy for us to think in code, but we don't want to think about that as the only way to implement the pattern.</p>
<p>What's more important is that we're staying true to the spirit of the pattern and the different parts that are described. How we actually implement it, it's up to us. Now definitely, we should use solutions that are already out there if they fit in our environment. But if our environment is a little bit different, it is okay to create your own solution to one of these problems.</p>
<p>Now the last thing that's part of the design pattern is something people don't like to talk about much and that's the <strong>consequences</strong>. Usually when we're having those day-to-day conversations, someone might come up and say, "Well, I was using the factory method pattern here and it was brilliant. It did all these awesome things that I needed exactly right for my code." But just like all of our other tools, our design patterns have both pros and cons. They have the solution to a particular problem but usually, there are some consequences that come along with that.</p>
<p>Now those consequences aren't usually showstoppers. They're not things that say, "Oh, I better not use this pattern because it's got this huge problem." Usually, they're just things that we need to keep in mind when we do implement the pattern so that we don't get ourselves into trouble. Again, we'll see some of that as we look at some examples today.</p>
<h3>The Gang of Four Patterns and Categories</h3>
<p>Now I mentioned that the Gang of Four described 23 design patterns and here they are. We'll be specifically looking at three of these patterns today because actually again, like I mentioned, as a developer I have used a bunch of these patterns just accidentally. So, we'll just picking out three of them specifically to see how we've been using them.</p>
<p>Now, the Gang of Four actually put these into categories. So, there's actually a set of patterns that are known as the <strong>Creational Patterns</strong>. These have to do with how do we instantiate an object or how do we get our objects into our application itself.</p>
<p>Then there's also a set of <strong>Structural Patterns.</strong> These have more to do with how do our pieces fit together? We've got these different pieces and can we put them together in different ways or somehow figure out different ways to present our objects in a way that makes sense?</p>
<p>&nbsp;</p>
<p>Then the third category is the <strong>Behavioral Patterns.</strong> This just describes how our objects might behave in certain instances. Again, these are all designed to give a solution to a certain problem in our environment that occurs over and over again.</p>
<p>Like I mentioned, the Gang of Four book, it's really, really important. I would encourage you to read it at some point in your career, but I would not use that as a starting point. Like I said, the reason for that it is rather academic. If you're a hardcore computer scientist, you might really love it. But if you're just a developer who's just trying to get code out the door to make your users happy, it might be a little tough to read.</p>
<p>My copy is actually from 2008. That's when I got my copy and put it on the shelf to make me look really smart. I actually tried three different times to get through the book and it turned out, I just wasn't ready for it yet in my career. Now, when I did get through it again, it was really important. It's been extremely useful to me since then, but it is kind of hard to get started.&nbsp;</p>
<h3>The Book Head First Design Patterns</h3>
<p>Now, if you're brand new to design patterns, I would highly, highly recommend this book, Head First Design Patterns from O'Reilly.</p>
<p>Now, the reason I give book recommendation is because that's how I learn best. I love books. I absorb books. They are really helpful to me. So if you're not a book person, there's lots of other resources out there, but this one is excellent. The thing that I like about this is that it actually covers 12 of the Gang of Four patterns. So, it takes 12 of those 23 patterns and it actually starts with the Gang of Four description itself.</p>
<p>It's not like it's trying to come up with something new. It's not trying to describe some new idea of what patterns are. It's just taking the Gang of Four patterns and describing them in a way that's a little bit easier to absorb. The Head First Design Patterns, the Head First series is all about how do we get information into your head in a way that we can understand. So, it's an excellent, excellent resource for that.</p>
<p>Alex:</p>
<p>By the way, I remember it has also samples and I think all the samples are in Java language. Is that correct?</p>
<p>Jeremy:</p>
<p>Yes, that is correct. All of the samples are in Java in this book. It actually mentions it in the introduction that if you're a C# programmer or another curly-brace language programmer, you'll have no trouble following along and that was actually my experience. But if you are specifically saying, "You know what, C# examples would be way, way better for me," there's tons of people who have created these samples in different languages online. So you will be able to find these examples in C# if that's what you really need.</p>
<p>Alex:</p>
<p>Okay. Thanks.</p>
<p>Jeremy:</p>
<p>Yeah. In fact, really the only thing that I ran into in this particular book is they had one that was specifically oriented towards JavaBeans. That's a little more specifically to the Java environment, but understanding the concepts was not difficult.</p>
<p>Alex:</p>
<p>Right. Okay. Okay, cool.</p>
<p>Jeremy:</p>
<p>I've told you here's what patterns are and I've showed you a book that I've told you not to read yet. I've showed you another book that says, "Hey, this is a good place to start." But again, if these things happened way back and started in 1994, aren't they relevant? Do they still matter to me?&nbsp;</p>
<h3>Why Care about Design Patterns?</h3>
<p>Why should I care about these as a developer? The answer to that is there're several reasons. Again, these are things that have seen in my own career and why I just love talking about design patterns.</p>
<p>The first one is that these are well described solutions. People way smarter than me have been thinking about this for a long, long time. So, rather than having to come up with my own solutions to the problem, I can rely on somebody else who's already thought about it. Again, there's a lot of implementations out there as well.</p>
<p>The other thing is that this gives us a shared vocabulary as developers. Now pretty much every industry has its own secret language. So doctors and lawyers have all their own secret words that normal people don't understand. This is actually the secret language of developers. So we can talk in the hallway and say, well yeah. I've got a facade over here and a mediator over there. It's like talking in code.</p>
<p>Now, I like to think about it that way, but it's actually more useful than that because it gives us a very concise language that we can use to speak to each other. It's not just a secret code. For example, I could come up to you and say, "Well I have this one object. When it changes state, it actually sends out a notification and I have this other object that's subscribed to that. So, it receives a notification whenever the state changes," or I can say, "I'm using an observer here."</p>
<p>A lot of times when we're talking to other developers, maybe we're trying to work through a problem, it's not usually specific lines of code that we're having problems with. It's usually that we're having problems with the bigger concepts and how they fit together. So if I can say that I'm using an observer rather than describing a particular implementation, now I can have that conversation stay in that design area that I want it to be in. Something that I love in my world, because of that language is that it does let me stay in design mode longer.</p>
<p>I'm one of those people who just loves the whiteboard. I don't do heavy, heavy design upfront, but I like to know where my code is going. So, here's the big pieces. Here's how they fit together. I had an awesome manager when I was working at this particular corporate job because whenever she would walk by my desk and I would have my feet up on the desk and I was just staring at the whiteboard not doing anything else, she knew I was working because as a developer, my job isn't really to type as much code as I can. My job is to actually solve problems.</p>
<p>So, there's a lot of thought that goes into that. Again, patterns let me figure out how do these big pieces fit together, how do we make them work, and how can I get this into my particular application and make my users happy because in my world, it's all about making my users happy. If I'm not making their lives easier, then I'm completely failing in what I do.</p>
<p>The last benefit when we start using design patterns in our every day speech is that it will hopefully encourage other developers to look into them as well. So, if you're having a hallway conversation and you're like, "You know what, I was using the mediator here. It was a perfect thing for this particular problem that I had and here's the implementation I used and it actually solved the problem." If there's another developer that's overhearing that conversation, they might say, "I'm not sure what the mediator pattern is, but maybe I should look into that."</p>
<p>It just will spread the use of this design pattern language just through our industry as new developers join all the time. That's a huge part of it because our industry is doubling in size every five years. That means that half of all developers out there have less than five years experience. If you're a senior dev like me who's been in the industry for a while, it's great to think about all the new people who are joining and how do we get them up on board and get them to a great productive place like I have been for a while?</p>
<p>This is what design patterns are and why we should care about them, but really where I want to spend the rest of the time is looking at how we as developers are already using these patterns even though we don't realize it. I'm going to look at three of the Gang of Four patterns. We'll see, you know what, how we're using this and once we recognize it now, we can use it more intentionally.</p>
<h3>Observer Pattern</h3>
<p>The first pattern we have is the observer pattern. Like I mentioned, the Gang of Four descriptions can be ... They're not difficult to read, but you do have to stare at them for a little while. Here's the Gang of Four description of the observer pattern. "Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically."</p>
<p>Do you know what that means? All it means is a publish&ndash;subscribe relationship. That's what the observer is. It's describing a publish&ndash;subscribe relationship. As an example in the real world I'm going to point to everybody's favorite time waster which is Twitter and in particular, the follow functionality in Twitter. If you follow me on Twitter, you actually become an observer of me. When I change state, meaning I publish a new tweet, you're automatically notified of that. That's all it is. The observer pattern is simply a publish&ndash;subscribe relationship.</p>
<p>Let's go to some code and see how we actually use this in our day-to-day coding practices. The code is all available on GitHub. I'll have a link on the last slide so you can go download that. If you look at the solution that I have here, it has a set of five different projects that describe different patterns. Like I said, we have time to look at three of these today. If you want to get some bonus content, you can download the code and take a look through it.</p>
<p>I'm going to start out by looking at the observer pattern. Now, before I write any code, I want to run this application because I want to show you my amazing UI development skills. I'll give you a second to take that in because I know it's a little overwhelming. What we have here is a button which doesn't do anything when we click on it. There's a couple of text blocks on there that don't have any content at the moment. Well let's go ahead and fill in some code and we'll see how implementing an event handler is really an example of the observer pattern.</p>
<p>I'm just going to go to the code behind my form and rather than hooking up the event handlers using the designer, with the properties, we'll do it in code. My button is called ClickMeButton. So I just have to say ClickMeButton.Click. Then I say plus equals, and Visual Studio says, "Hey, it looks like you're trying to hook up an event handler. Would you like me to create that? If so press tab." Yes please. "Do you want to call it this?" No. Let's go ahead and call this observer one and hit enter.</p>
<p>I just love things that do this for me. Visual Studio has awesome, awesome stuff built into it. Now, in this case, I just don't want to hook up one observer. I want to hook up three. I'm just going to duplicate some code here. We'll have an observer two and observer three and we'll just copy this method down. I've got an observer two and observer three.</p>
<p>Now in this observer one code, I'm just going to set the TextBlock1.Text to hello from Observer1. Down here in the second one, I'll set TextBlock2.Text to hello from Observer2. Then way down here at the bottom, we'll switch things up a bit and we'll do a MessageBox.Show and we'll say hello from Observer3.</p>
<p>Now hopefully none of you are baffled by this code, and that's really the point because what we're looking at is we're looking at things that we do all the time. When I run this application, hopefully there are no surprises. If there are some surprises, then I'm going to get a little depressed about my programming abilities, but when I click on the button, oh look at that. Our two text blocks built in and we also got the message box popup.</p>
<p>But we've also used an implementation of the observer pattern. We have actually set up a publish&ndash;subscribe relationship. In this case, the state that we're subscribing to is the click state of the button. Whenever the click state of the button changes, all of my methods in this case get notified, "Hey, this has changed. Go ahead and run your code." That's really all there is to implementing the observer pattern.</p>
<p>Now what's interesting about this is that there are a lot of different ways that we can do this. Since it's no longer 1994, our languages and frameworks actually implement a lot of these patterns for us so that we don't have to worry about it. For example, if we're talking about the observer specifically in the C# world, obviously event handlers are out there and hooking up an event handler is one of the first things that we learn as developers. You do that hello world with your first form application and you click the button and there you go.</p>
<p>Creating an event handler is not all that much more difficult than that. So, it's something that developers can do really, really easily. But the thing is we might look at our problem and say, "You know what, an event handler isn't the right solution for this. I know it's built in and it's there. If it works, great. I don't have to write any extra code. But if it doesn't fit our scenario, we can look elsewhere."</p>
<p>There's something called an event aggregator. I first ran across this concept with the Prism framework. Prism is a framework that's designed to work in the XAML world. There's this concept of event aggregator. When you use this, the publishers and the subscribers don't have to know anything about each other. That's a benefit because I can have publishers and subscribers completely separated.</p>
<p>So, all each object needs to know about is the centralized event aggregator. So an observer, a subscriber, all they have to do is hook up to the event aggregator and say, "Hey, please notify me if this particular event happens." In fact, you might even say, "You know what, notify me if this event happens and it has this particular value in the payload." It can get kind of interesting with what you do with that.</p>
<p>On the publishing side, again the publisher goes to the event aggregator and says, "Hey, I would like to publish this event please and here's the payload that you should use for that." Again, the publishers and subscribers don't have to have any direct connection.</p>
<p>Now you might also say, "You know what, that doesn't work for me either." Well, starting in .NET 4.0, we got two new interfaces, IObservable&lt;T&gt; and IObserver&lt;T&gt;. These are just shells. They're frameworks that we can use to fill in our own methods that says, "You know what, here are some ethics that you can use to implement your own custom observer." You might even say, "You know what, this doesn't work for me either."</p>
<p>That's the thing about design patterns. We're not locked into a particular implementation, but once we recognize the problem and I say, "You know what, I have this publish-subscribe problem. What do I do?" Well, I can say, "You know what, event handlers are built in. Will that work for me?" That way, we don't spend time spinning our wheels coming up with custom code when we can go look for solutions online or inside our own frameworks themselves.</p>
<p>Alex:</p>
<p>Okay. I was just wondering are there any consequences of observer pattern because we just looked at the implementations, but usually there should some consequences or maybe some downsides or?</p>
<p>Jeremy:</p>
<p>Yes. There are always consequences. Again, with every tool that we have, there's consequences. Let's just go back and look at our code and see if we can think about what those consequences would be in this case. When I'm using the Observer pattern, something to think about is I might never get notified at all.</p>
<p>So, it's possible, let's just rerun this application, that I have this application and nobody ever clicks the button. Now for our simple example, that's not really a big deal, but let's say we were creating a stock ticker application that was getting communication from some service that was providing us with values of different companies.</p>
<p>Well if we never get that first notification, well what are we going to do? Well, we might decide we put in the default message or something like that or we might have something that says, "Hey, we haven't received any data yet just to let the user know what's going on." Again, it doesn't stop us from using the pattern, but it's something to keep in mind.</p>
<p>Another thing specifically with the observer is that we don't know how frequently we're going to get notified. I might get notified once an hour. I might get notified a million times a second. I don't know. Now in our particular application, we kind of have a limiting factor because our message box is a modal dialog so we have limited how quickly we can handle things in this particular application, but again it's something to keep in mind.</p>
<p>Then the other thing is that we don't know how frequently we'll be notified. Did I say frequently or often? They're so related. I might get notified one time or I might get notified a million times. Regardless of the total numbers of notifications I get or how close together they are or how spread out they are, those are things that we think about with the observer.</p>
<p>Alex: Okay.</p>
<p>Jeremy:</p>
<p>It would be nice if things came for free. But then again if we didn't have to judge the pros and cons of each of our tools, they wouldn't pay us the enormous amounts of money that they do to be programmers. I hope everybody is paid enormous amounts of money. That's the observer pattern. Again, it doesn't have to be complicated. Now obviously the situation that I showed was pretty simple, but it's something that we can think about in the future. "Hey, I've got publish-subscribe. What do I do about it?"</p>
<h3>Proxy Pattern</h3>
<p>The next pattern I want to look at is the proxy pattern. Here's the Gang of Four definition, "Provide a surrogate or a placeholder for another object to control access to it." Now for this, I'm going to use a legal concept from the U.S. which is where I live, and it's called power of attorney. My brother actually lives in Bamako in Mali, West Africa. I live in California on the West Coast of the United States. Now, he has assigned me power of attorney, which really makes me his proxy.</p>
<p>What that means is let's say someone wants to do business with my brother. Now, they could figure out well okay, how do I get this papers over to my brother in West Africa to sign. Unfortunately, U.S. has some kind of archaic laws. Like a fax signature is legal. So. it's like okay, well let's fax them over and he can sign them and fax them back. Of course, the first thing you have to do is find a time machine so you can go back to 1996 to fax something. But another option is that this person could have me sign the documents as my brother's proxy. That in the U.S. is exactly the same as if my brother had signed those documents himself.</p>
<p>As his proxy, I can work on his behalf, and to the individual interacting with us, interacting with me is exactly the same as interacting with my brother who is 6,000 miles away from where I live. That's actually a pretty common implementation when we're talking about the proxy pattern in code. A lot of times we're dealing with a network resource.</p>
<p>In this case, I want to show an example of working with SOAP services. Now, I know SOAP services have gotten a bad wrap recently because people are like, "Oh, REST is the trendy thing to do. You should be doing that. SOAP is archaic. You should never use that. REST is the replacement for SOAP." To that, I say, no. Both REST and SOAP have their pros and cons just like all of our tools. I love that we have more tools in the toolbox, but let's see which ones are great for certain things and which ones are great for other things. Rather than replacing my tools, I just want to make my toolbox bigger.</p>
<p>Now in the case of SOAP services, what's awesome about this is they're self-describing. What that means is that my development environment, in this case Visual Studio, can actually create a proxy object for me. If you've used a SOAP service in .NET, you've actually used an implementation of the proxy pattern.</p>
<p>Let's take a look at the service that I have. You can see it's really exciting. It just has one method called GetPeople and it returns a list of person objects. If we just peek at this, we'll see that the person class is pretty simple. It's just the first name, the last name, a start date, and a rating. That's just the shape of our data. Then in this case, I just have a hard coded collection of objects that it's returning. So, I'm not even going to database or anything like that. This will provide us with the data that we can use in our UI.</p>
<p>Now before we look at the UI code, let me just go ahead and run this application because again I want to you to be amazed with my UI skills. This time with have a button and a list box. Yes, I know we're moving up in the world. Again, the button isn't doing anything at this point in time. Now the advantage of using the WCF SOAP service is that I can have Visual Studio generate a service reference for me, which is really creating a proxy object.</p>
<p>For this, I just right click. Inside the project where I want to use the service, I say add service reference. In this case, I can click the discover button and that will find all of the services that are in my solution. I can say, "Oh yeah. Here's this one here. Is this the one I want?" Yes. It has that GetPeople method in it. I can just fill in the rest of this and click okay and it will stab out all of the things that I need. Now I have already done that in this project, so I won't do it again but let's see how we actually use this in the code.</p>
<p>Again, we'll go ahead and go to the code behind of our form. Again, this is just the form that has the button and the list box on it. Now, all I need to do is new up an instance of this proxy object that Visual Studio created for me. So I'll say var proxy = new PersonServiceClient. That's just the name Visual Studio gave to my proxy class. Then if I say proxy., you'll notice that I have a GetPeople method exactly like I have on the service object.</p>
<p>When I look at this, I see this returns a list of person objects. Okay. List&lt;Person&gt; people = proxy.GetPeople. That looks like I need a using statement for bringing in the collection. Then all I need to do is get this into my list box. Well in this case, I have something called a PersonListBox that I can just say it's ItemSource equal to what's coming back from this. When I do this and run my application, again hopefully there's no surprises, we click on the button and we'll see that our list box actually populates.</p>
<p>Now, that's not very impressive because this code looks pretty normal to me. But the thing is once we start thinking about what's going on behind the scenes, now this becomes more important because if I want to call a SOAP service, what actually has to take place? Well, first of all, SOAP is XML based. To create a SOAP request, I have to make this big ball of XML in a specified format. Then I have to send that SOAP request across the wire usually by HTTP. Then I have to wait for a response to come back. Then I have to retrieve the response, which again will also be by HTTP.</p>
<p>Then I have to parse the response that comes back because it's actually a SOAP response which is a big ball of XML. Then I have to take the things out of that that I need and turn them into C# objects that I can actually use in my code. This is what I have to do with a SOAP service, or I can use the proxy class that my IDE generates for me.</p>
<p>Let's take a look at the service itself. Again, this just has a single method. Let's pretend this wasn't a service. What if we were just using this directly. How would I use it? Well, I would new up an instance of this person service class. So new person service and then I would call Service.GetPeople. That's how I would use it directly just to use that GetPeople method on an instance object.</p>
<p>How am I using this proxy object? Well, I'm newing up an instance of person service client in this case, which again is the proxy, and then I'm just calling proxy.GetPeople. So, I'm interacting with this remote resource exactly the same as if it were a local resource. Again, that's very, very powerful. Again, this is one of the things that I really love about SOAP services is that they are self-describing.</p>
<p>Now the Gang of Four actually, something that's interesting, is the example that they use for their example of the proxy and that is well, let's say you have this picture. Back in 1994, our networks were really slow. So if I just wanted a photo to come across the wire, it might take 30 seconds to a minute, and that would be for an extremely low resolution picture compared to our current standards.</p>
<p>So they said well instead of doing that, what if you create a placeholder in your application rather than bringing down that big resource off the network. Then if somebody clicks on that, then you can go through the process of retrieving the object itself. At first, I thought, well nobody has got that problem anymore. Our networks aren't that slow. I'm just laughing about how long it takes for a picture to come across the wire, but then I started thinking about our mobile devices.</p>
<p>Yes, we like to think that our mobile devices have high speed connectivity everywhere, but at least in the U.S. I ran into big chunks of country that have very little connectivity. So I might stop along the side of the road to take a break and pull out my phone to check Twitter and my connection says 2G. I'm like 2G? I haven't seen a 2G connection for years.</p>
<p>I'm trying to look at Twitter, but Twitter is just eagerly downloading all of the images because that's what it normally does. It's like well, maybe this application should be more network aware and say well, if you're on a constrained connection, maybe I should put placeholders and only download things when you actually ask for them. Those are things that we can actually use in our current day-to-day operation.</p>
<h3>Facade Pattern</h3>
<p>Now I do have one more pattern that I want to go through and that's the facade pattern. Again Gang of Four description, "Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher level interface that makes the subsystem easier to use." All this is talking about is wrapping a complex API and making it easy to use.</p>
<p>As a real world example, I'm just going to talk about my home entertainment system. Now, I'm one of those people that's got multiple remote controls pointing to multiple pieces of equipment. If I want to play a DVD, I have to turn on the TV if it's not already on. Then I have to set the input to HDMI 1. Then I have to turn on the stereo if it's not already on and make sure the stereo is set to Aux input. Then I have to turn on the DVD player if it's not already on and press play on that.</p>
<p>Now this is absolutely no problem for me because I'm a couch potato and I can reach over and find those buttons on the remote controls without even looking. But the problem is is that I also do a lot of travel and I have two cats that don't do a lot of travel. So, I have a friend that stops by and checks on my cats when I'm out of town and for whatever reason, she likes to watch DVDs with the cats.</p>
<p>I don't want to try to teach her how to do this complex subsystem. So, for that, maybe I need a universal remote control, and there's just a button on there that says play DVD. It's up to that universal remote to figure out okay, what do I need to do to make this actually happen? That's really all that the facade pattern is. Wrapping something complex, making it easier to use.</p>
<p>Now as far as coding is concerned, if you&lsquo;ve used a foreach loop, you have actually used an implementation of the facade pattern. I love foreach. Foreach is just one of my favorite things out there because it seems like I'm constantly iterating through stuff. Let's just take a look at this.</p>
<p>This application will look familiar. It's a button in a list box. Again, right now the button is not doing anything. If we look at the application itself rather than accessing a service, I just have a hard coded class here that does the same thing the service did. It will just return the hard coded list of these person objects that I can use.</p>
<p>If I flip to the code behind, what I see is that I'm already calling that GetPeople method and I'm using an IEnumerable&lt;person&gt;. Now IEnumerable is an interface that's pretty much on every collection in .NET. It also shows up in a couple of interesting places. Anything that uses IEnumerable or that implements IEnumerable, we can use in a foreach loop.</p>
<p>So I can foreach over this and say foreach (var person in people), PersonListBox.Items.Add(person). I can just iterate over that because the IEnumerable describes that and foreach makes it really easy to use. Now when I click on the button, my list box is populated.</p>
<p>Now like I said, foreach is actually is a facade. It's a wrapper around IEnumerable itself. Let's just comment on that code and see what it would be to use this directly. If I look at the people object and say people., in addition to the stuff that we get from object, there's a method called GetEnumerator. This GetEnumerator will return me an IEnumerator&lt;person&gt; which we'll call enumerator.</p>
<p>Then once we have this enumerator, this is the thing that we can use to kind of loop through things. If I say enumerator., we'll see we have quite a few things that we can choose from. First is MoveNext because when we're talking about something, we can enumerator through. All we're doing is saying, "Hey, give me the next one. Give me the next one. Give me the next one. Give me the next one. Give me the next one," until there aren't any more normally.</p>
<p>In addition to the MoveNext, there's also a current property and that will be whatever the current item is that I just moved next to. There's also a dispose because this implements the IDisposable interface. Then there is a reset, so the reset will go back to the beginning of this enumeration so that we can start over.</p>
<p>If we look at MoveNext, this doesn't return the next item. Instead it returns a boolean value, a true false, and that lets us know if that MoveNext was actually successful. Well, that looks like something really awesome to do in a while loop. I can say while MoveNext. Then inside the code, I can say PersonListBox.Items.Add and I can say, enumerator.Current. That will actually give me the current item that I'm on after I move next.</p>
<p>If we run the code in this state, we'll see we get exactly the same functionality which is that my list box is populated after iterating through these objects. So, foreach actually takes this code and wraps it into a way that's easier to use. It actually goes a step further because like I said, the IEnumerator also implements IDisposable. I'll probably want to wrap this up in a using statement so that when I create it I also make sure that dispose gets called properly.</p>
<p>The thing is if I'm one of those nerdy people that looks at IL, the code that's generated by this code here and the code that's generated by the foreach is actually exactly the same in the IL. So the foreach is in fact just a wrapper of facade around this code.</p>
<p>Alex:</p>
<p>Well, we know we can go even somewhat deeper, a bit deeper and we'll see that using I think can be called also a facade, right?</p>
<p>Jeremy:</p>
<p>Yes.</p>
<p>That's actually absolutely right because what using does is that it makes sure that dispose gets called regardless of whether there's any exceptions. So if you actually look at the code that's generated by using statement, it creates a tri-finally block and it makes sure that dispose is called inside the finally. So yes. That's a facade around a more complex infrastructure as well. These are all things that make our code easier to code and easier to use. Now, when we're talking about consequences to the facade, not all of the members are necessarily exposed. So we thought there was a reset method on the enumerator. There's no way to access that reset method when we're in a foreach loop, but quite honestly, generally what I would do is just spin another foreach loop and start over again. So a lot of times those consequences, again something to keep in mind, but not necessarily something that keeps us from moving forward.</p>
<h3>Summary</h3>
<p>Those are the three patterns that I wanted to focus on today to show us that you know what, we're already using this. If we look at design patterns, again these help us solve problems that occur over and over and over again in our environment. Again, it's just the core of the solution. It's not giving us a particular implementation. In fact, it describes it in such a way that you can use the solution a million times over without ever doing it the same way twice.</p>
<p>Now again, I would not recommend that because we should not be reinventing the wheel, but once we understand design patterns, now I can say, "You know what, I need an observer. So rather than building my own observer, let me go online and see what other people have done and if I can use that, awesome. But if I can't, you know what, maybe I'll take a wheel and tweak it a little bit."</p>
<p>Again, why do I care about this? These are well described solutions from people who are way smarter than I am and I just love to leverage their code so that I can move forward more quickly. It's a shared vocabulary that gives us a very concise language. Hopefully right now if I say I'm using the observer pattern you know what I'm talking about. Even if you don't know a specific implementation, you kind of know the big pieces that are there.</p>
<p>Again, this allows me to stay in design mode longer, and I really love that because now I can think about the pieces and how they fit together. Then of course, if I start using this in my every day speech, hopefully it will encourage the other developers around me to use it as well.</p>
<p>That's what I have for you today. Again, here are some links that you can get to the <a href="https://www.pluralsight.com/courses/design-patterns-on-ramp" target="_blank">Design Patterns On-Ramp course</a> on Pluralsight, as well as the code samples on GitHub. If you follow the GitHub link, there's also some links to some articles and other things as well. With that, let's see what our questions look like. Alex, have you been keeping track of those?</p>
<p>&nbsp;</p>
<h2>Q&amp;A</h2>
<p><strong>Q: I</strong><strong>s there some restriction implementing patterns in JavaScript?</strong></p>
<p>A: Well, there are different patterns that are using in different environments. For example, the Gang of Four patterns are very much geared towards the OO world. In the functional world and other worlds, there are different patterns that are talked about. JavaScript is one of those interesting languages because we can kind of treat it like an OO language even though it's not and we can kind of treat it like a functional language as well. So it really depends on the approach that you're taking.</p>
<p>There, I would say, yes there are definitely patterns that are useful in that world and I'm sure there is ... JavaScript is not my world so I'm not going to talk about any specifics, but I would say yes, there are definitely patterns out there in that world as well.</p>
<p><strong>Q: I</strong><strong>s copy-paste also a design pattern?</strong></p>
<p>A:&nbsp;Copy-paste actually is anti-pattern. I also have a talk I do on clean code. I talk about how copy and paste is generally evil because it causes us problems. In fact, I don't even call it copy-paste in my normal development. I call it copy-pasta because if you do it enough times, you will end up with spaghetti code.</p>
<p><strong>Q: S</strong><strong>hould we say that facade is an example of obstruction or something like that?&nbsp;</strong></p>
<p>A: That would be something I would need to think about a little bit more. I guess it could be considered a form of obstruction, but it's more of a wrapper. I would have a tendency to say wrapping rather than obstruction because when I think of obstruction I think about things like interfaces. I love interfaces. I have a whole Pluralsight course on interfaces. Those can help us with loose coupling, things like DI and that kind of thing.</p>
<p>This is one of actually those gray areas. It's actually an interesting topic because I'll often get asked is X an example of the Y pattern? That's where we have to stop and think about what's the spirit of the pattern. What is trying to accomplish. In that situation, obstruction actually isn't a design pattern in that case. It's more just a programming concept, but it's kind of that same thing. It's like what are the goals of obstruction and what is it trying to do? My gut instinct is to say no, but it's a gray area. It's one of those things that we can have great discussions with each other about.</p>
<p><strong>Q: Does the usage of foreach have disadvantages in performance in comparison with using the reset method, what you talked about in this example?</strong></p>
<p>A:&nbsp;It has absolutely no difference. Again, I'm kind of one of those nerdy people who likes to look at the IL code that's generated by the compiler. Again, the code that I showed using enumerator with the while loop and the MoveNext and all that, that is exact. If you look at the IL, exactly the same code is generated between that and the foreach loop. So there's absolutely no runtime differences at all. I would guess there might be a compile time difference, but it's probably one of those things you wouldn't notice.</p>
<p><strong>Q: Out of all the design patterns, how does a newbie decide which patterns to use for a given problem1? In other words, is there a way to filter out the patterns to arrive at a subset of suitable pattern?</strong></p>
<p>A: This is a difficult question to answer. There are multiple ways to solve a problem. And there are also multiple design patterns to solve a single problem. The differences in the pattern have to do with what approach is taken. And this often leads to a different set of consequences. I would start by understanding the Gang of Four patterns. These are very common problems/solutions. And it will help understand the more complex patterns than you might run across. Just like learning anything new, start with the basics and talk to people or look online to see what people who are working in the same problem-space are doing.</p>
<p><strong>Q: Does design patterns always obey SOLID principles? Or is it even important to do so?</strong>A: The SOLID principles are &ldquo;best practices&rdquo; in the object-oriented programming world. I don&rsquo;t like to use the term &ldquo;best practice&rdquo; because that sounds like it is always the right answer. But with my experience (but success and failures), I&rsquo;ve found that they are a good place to start. If I have a reason to not use the practice, I&rsquo;m okay with that as long as I understand the pros and cons of a particular situation. In general, the Gang of Four patterns can help us adhere to the SOLID principles, but it all comes down to how we use them.</p>
<p><strong>Q: Any example of factory or abstract factory which we are using and not aware of?</strong></p>
<p>A: Unfortunately, I can&rsquo;t think of one off the top of my head. But I have use the Factory Method to dynamically load objects from the file system. If you&rsquo;d like an example, you can see my materials on C# Interfaces: <a title="http://www.jeremybytes.com/Demos.aspx#INT" href="http://www.jeremybytes.com/Demos.aspx#INT" target="_blank">http://www.jeremybytes.com/Demos.aspx#INT</a>.</p>
<p><strong>Q: Isn't Proxy pattern built-in pattern with tools like Visual Studio?</strong></p>
<p>A: The implementation of the Proxy pattern that we looked at (accessing a SOAP service) is definitely built in to Visual Studio. But there are other scenarios we might want to use the Proxy, such as using a thumbnail image instead of bringing down a full image or the difference between downloading a song and streaming a song. So we do have certain implementations of patterns that are built into our language and tools. Some other examples in C# are Iterators (IEnumerable) and Observers (Event Handers / IObservable).</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;"><strong>Q: How do we know that we need to use design patterns to a specific problem? Because most of the problems can be solved without using any design pattern.</strong>A: Learning about design patterns helps us see what solutions are available (and hopefully we can borrow someone else&rsquo;s solution rather than creating our own from scratch). We can build a house by stacking bricks, but if we understand the patterns of walls, lintels, and foundations, we&rsquo;ll end up with a much better structure. Programming patterns are the same way. I spent many years using patterns accidentally because I ended up solving these common problems. But once I could put a pattern name to a problem, I could look at how other people implemented the pattern. Sometimes I use those solutions, and sometimes I used them for ideas to incorporate into my own solutions. But that lets me use much better than what I could come up with on my own.</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">&nbsp;</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;"><strong>Q: There are plugins which allow patterns to be implemented in Visual Studio. Would you advise using them or rather learn the codes and implement them?</strong>A: I haven&rsquo;t used the tools, so I can&rsquo;t give an informed answer. As a general rule, I like to understand what the tool is doing before I use it. For example, I use Dependency Injection (DI) containers when I code, but I was not able to use them effectively until I understood what the containers were doing &ndash; and more importantly why. I would think it&rsquo;s the same with pattern tools. I want to understand the patterns (particularly the &ldquo;why&rdquo;), and then I would be fine with letting a tool do the hard work for me. This would be similar to how I let Visual Studio create the SOAP proxy for me. I don&rsquo;t need to understand all of the details (XML, HTTP, etc.), but I do need to understand why I&rsquo;m using the proxy.</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">&nbsp;</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;"><strong>Q: What pattern should I use for creating exception handling library?</strong>A: Exception handling is a pretty big topic. It turns out that the built-in exception handling in .NET uses the Chain of Responsibility pattern (this is one of the examples I show when I have a bit more time to talk about patterns). When an exception is thrown, it looks for a catch block that can handle it. If it can&rsquo;t find one in the current method, it walks up the call stack to the calling method. Then it just keeps walking up the call stack until something can handle it, or it drops off the end. (And this is why it&rsquo;s a good idea to put a global exception handler somewhere in the code to make sure the user has a good experience.)</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">&nbsp;</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;"><strong>Q: Instead of using Proxy pattern for WCF services, I prefer use ChannelFactory object to use same object from the service without any MAPPER. Is there any other way to use Proxy for this case?</strong>A: As we saw in the definition of design patterns, there are a million different implementations. If there is a built-in implementation (such as the WCF Proxy in Visual Studio), I like to start there since it&rsquo;s &ldquo;free&rdquo;. But if I find that my needs are a bit different (like I want to optimize for speed), then I&rsquo;m free to look for different implementations or create my own. So there are lots of ways to use a Proxy in this situation. Unfortunately, I haven&rsquo;t looked into them since the built-in one has worked for the situations I&rsquo;ve needed.</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">&nbsp;</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;"><strong>Q: What about structure diagram and code?</strong></p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">A: Often when patterns are described in pattern catalogs, they are accompanied by a UML class diagram. Personally, diagrams often cause more confusion for me than help, so I tend to not use them. It&rsquo;s easy for me to look at a class diagram and get stuck in a particular implementation when I really would rather understand the spirit of the pattern and the concepts behind it. Both the Gang of Four book and Head First Design Patterns include class diagrams (although the Head First book uses them for specific example code rather than the overall pattern).</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">&nbsp;</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;"><strong>Q: What pattern should I use for micro service implementation?</strong>A:Micro-services is a big topic. Looking for *a* pattern is like looking for a pattern for a web site. Generally, we would use multiple patterns to address the different problems that we are trying to solve. If we think of each micro-service as a self-contained application, then we can imagine using quite a few different patterns in putting it together.</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">&nbsp;</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;"><strong>Q: What is the difference between proxy and facade?</strong></p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">A: The main thing about design patterns is to look at the problem they are trying to solve. One way to think of the Proxy pattern is as a way to access a remote resource as if it were a local one (it&rsquo;s a bit more general than that, but that&rsquo;s the example we saw with the SOAP proxy). The Fa&ccedil;ade pattern is a way to reduce complexity by creating an easier way to interact with something (as we saw with the &ldquo;foreach&rdquo; example). The implementation of the SOAP proxy can also be considered an implementation of the Fa&ccedil;ade pattern since it&rsquo;s wrapping the complexity of making the SOAP call (XML, HTTP, etc.). This is part of the fun when we start looking at patterns. We find that complex systems are often a combination of multiple patterns.</p>
<p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">&nbsp;</p>
<p>&nbsp;</p>
<p><strong>Q: When I have multiple patterns that can be used to solve a problem, how can I choose one, or can I combine them?</strong>A: This is one of those areas where we try to understand our tools better. There are multiple patterns that address the same problem (for example, there are many patterns that are variations of the Gang of Four patterns). In that situation, look at what the pattern is optimizing for. It may be addressing a particular consequence, such as performance or memory usage. If you are concerned about that consequence, then it may be a good choice. But if that consequence isn&rsquo;t important to you, then something else may be better.</p>
<p><strong>Q: Taking into account the example of IEnumerator and foreach, what would be the most correct to use?</strong>A: Since &ldquo;foreach&rdquo; gets compiled into the same code as using &ldquo;IEnumerator&rdquo; directly, I would use foreach. This makes our code more readable &ndash; and we need to make sure our code is readable by humans in addition to the computer. If there were a difference (for example, if the direct use were faster), even then I would look very carefully to see if that difference is important to me.</p>
<p><strong>Q: You said foreach is a facade pattern. Is it also an iterator? Does it mean that any concrete implemenation can be a combination of multiple patterns?</strong>A: Yes, foreach is an example of the iterator pattern. In fact, I talk about this when I have more time to talk about design patterns. Many things we run across are implementations of multiple patterns. Another example is data-binding. This implements the Observer (when the UI elements change, the backing objects are changed) and also the adapter pattern (when a backing field is a number, it is displayed in the UI as a string). In reference to &ldquo;foreach&rdquo;, I usually call this an &lsquo;Iterator&rdquo; since that is its primary purpose &ndash; to iterate over items. The &ldquo;Fa&ccedil;ade&rdquo; pattern is more an implementation detail than the primary purpose.</p>
<p><strong>Q: Which design patterns are useful in writing cross-platform code?</strong>A: There are a lot of patterns that we can use in cross-platform code, just like there are lots of patterns we can use in any application. The patterns we use depend on the needs that we have. For example, if I wanted specific UIs for each platform and wanted to share presentation code, I would look at various patterns that could help with loose coupling, such as Abstract Factory or Inversion of Control. But these aren&rsquo;t strictly limited to cross-platform concerns.</p>
<p>&nbsp;</p>
<div style="margin-right: auto; margin-left: auto; background-color: #edecec; padding: 10px;">
<h3 style="text-align: center; margin-bottom: 10px;">About the speaker, Jeremy Clark</h3>
<div><img style="float: left; margin-right: 10px; margin-top: 0px; margin-left: 10px;" src="/assets/2017-03-23-webinar_recording_design_patterns_jeremy_clark/jeremyclark.jpg" alt="Jeremy Clark" />
<p style="margin-bottom: 10px;">Jeremy Clark makes developers better. By drawing on over 15 years of experience in application development, he helps developers take a step up in their skillset with a focus on making complex topics approachable regardless of skill level. He is a Microsoft MVP for .NET, and he has authored seven courses for Pluralsight, including "C# Interfaces", a course aimed at giving developers a clear understanding of abstraction. He loves speaking and has delivered over 200 technical presentations in the last 7 years in the United States and Europe. Jeremy lives in Southern California with 2 cats and a banjo. <a href="http://www.jeremybytes.com">Jeremy's blog</a>.</p>
</div>
</div>
<p>&nbsp;</p>
