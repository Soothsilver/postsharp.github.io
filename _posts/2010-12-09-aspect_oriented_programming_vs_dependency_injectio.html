---
layout: post
title: "Aspect-Oriented Programming vs Dependency Injection"
date: 2010-12-09 16:01:00 +01:00
categories: [Opinion]
permalink: /post/aspect-oriented-programming-vs-dependency-injection.html
author: "Gael Fraiteur"
---
<p>In my <a href="http://www.postsharp.net/blog/post/Anders-Hejlsberg-Dead-Body" target="_blank">response to Anders Hejlsberg</a> spreading <a title="Fear, Uncertainty and Doubt" href="http://en.wikipedia.org/wiki/Fear,_uncertainty_and_doubt" target="_blank">FUD</a> about aspect-oriented programming, I mentioned the common confusion that Aspect-Oriented Programming (AOP) and Dependency Injection (DI) are competing concepts. In this post, I will further clarify the differences and similarities between AOP and DI.</p>
<p>The timing seems perfect, because Dino Esposito just published the article: <a href="http://msdn.microsoft.com/en-us/magazine/gg490353.aspx" target="_blank">Aspect-Oriented Programming, Interception and Unity 2.0</a> in the December 2010 issue of MSDN Magazine. This is a great article and I highly recommend anyone involved in .NET development to read it. Like most dependency-injection frameworks, and several general frameworks (<a title="Extending WCF with Custom Behaviors" href="http://msdn.microsoft.com/en-us/magazine/cc163302.aspx" target="_blank">WCF</a>, <a title="Understanding Action Filters in ASP.NET MVC" href="http://www.asp.net/mvc/tutorials/understanding-action-filters-cs" target="_blank">ASP.NET MVC</a>), Unity offers an AOP-like feature: interceptors.</p>
<h2>What is Dependency Injection?</h2>
<p>Dependency Injection is a design pattern that strives to reduce explicit dependencies between components.</p>
<p>One of the benefits of reducing dependencies (moving from a tightly coupled architecture to a loosely coupled architecture) is the reduction in the level of awareness components have of each other, thereby achieving a better <a title="Separation of Concerns Defined (Wikipedia)" href="http://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank">separation of concerns</a> by implementing the &ldquo;program to an interface, not to an implementation&rdquo; design principle.</p>
<p>A common misinterpretation of this design principle among C# and Java developers is that clients should consume interfaces (the thing you declare with the <em>interface</em> keyword) instead of classes. I prefer the following wording: &ldquo;program to a <em>contract</em>, not to an implementation&rdquo;. The contract of a class is composed of its public members, augmented by their documentation (plus their formal preconditions, post-conditions and invariants, if applicable). To be even more precise: &ldquo;program to a <em>documentation</em>, not to an implementation&rdquo;. So if your aim is just a better separation of concerns, you don&rsquo;t really need interfaces, you just need the <em>public</em>, <em>internal, protected </em>and <em>private</em> keywords. It&rsquo;s important to note that in object-oriented design, interfaces are not the silver bullet. Not all framework designers follow the same philosophy: the Java class library relies more on interfaces than that of .NET, probably because .NET designers had negative experience with the all-interface approach of COM.</p>
<p>Programming to an interface (instead of a class) is useful when your component has to talk to many implementations of the interface. There are innumerable cases where this is useful (after all, we all want our architecture to be extensible), but let&rsquo;s face it: in as many cases, when our component needs to talk to another, we know perfectly well which implementation we have in mind, and there will never be a second implementation running side-by-side. So why use an interface here?</p>
<p>There are two cases when you want to program to an interface even if you know you&rsquo;ll always have a single implementation:</p>
<ol>
<li>You depend on a component that has not been delivered yet and need to start programming &ndash; and, more importantly, testing your code &ndash; right now. You need to simulate (mock) this component until it is delivered, only for the purpose of testing.</li>
<li>You depend on a component that has a persistent state (such as a database), real-world effect (such as a credit card processing system) or simply depend on a slow or unreliable resource (web service). You need to substitute these components with an implementation of your own, only for the purpose of testing.</li>
</ol>
<p>In these situations (which all happen to be related to testing), it&rsquo;s good that components are not wired together in source code &ndash; even if we know how they will be wired together in the final setup. So how do we wire these components together? This is where Dependency Injection comes into play.</p>
<p>With the DI design pattern, you instruct a &ldquo;container&rdquo; how the objects should be wired together, and you ask the container to wire the objects. Indeed, most of the time, you don&rsquo;t create new objects using the class constructor, but using a factory method of the container. The container would figure out which implementation you need to be wired to, and would return it to you.</p>
<h2>Aspect-Oriented Programming</h2>
<p>Dependency injection addresses the problem of wiring loosely-coupled components together. Aspect-oriented programming (AOP) solves a very different issue: taking a reality where some features (such as transaction handling or auditing) affect virtually all business requirements, and expressing this complex reality in a compact way, with minimal duplication of code (DRY principle). When we think of auditing, we want to look in a single source file. When we see a piece of code related to customer management, we don&rsquo;t want to see auditing code. As you know, this is impossible to achieve with plain object-oriented programming, and that&rsquo;s why aspect-oriented programming was invented.</p>
<p>Aspect-oriented programming allows you to specify an implementation pattern (using source code, not natural language) into a so-called aspect, and to apply the aspect to base code, typically to business or UI code.</p>
<h2>&nbsp;</h2>
<h2>Similarities and Differences between DI and AOP</h2>
<p>There are some similarities in the objectives of DI and AOP:</p>
<ul>
<li>Both achieve a loosely coupled architecture.</li>
<li>Both achieve a better separation of concerns.</li>
<li>Both offload some concerns from the base code.</li>
</ul>
<p>However, DI and AOP differ significantly in situations where they are found to be useful:</p>
<ul>
<li>DI is good when you have a dependency on a component, you just don&rsquo;t know to which implementation.</li>
<li>AOP is good when you need to apply a common behavior to a large number of elements of code. The target code is not necessarily dependent on this behavior to be applied.</li>
</ul>
<h2>Dynamic Proxies</h2>
<p>How did dependency injection ever become associated with aspect-oriented programming? It&rsquo;s simply that the DI pattern makes it easy to add behaviors to components. Here&rsquo;s how: when you ask a dependency from the container, you expect to receive an implementation of an interface. You can probably guess which implementation you will receive, but since you play the game, you just program to the interface. And you&rsquo;re right. If you ask the container to add a behavior (for instance tracing) to the component, you will not receive the component itself; instead, you will receive a <em>dynamic proxy</em>. The dynamic proxy stands between your code and the component, and applies the behaviors you added to the component.</p>
<p>Because DI frameworks have the ability to put behaviors between the client and the implementation of a component, DI has been identified as one of the technologies able to deliver AOP.</p>
<p>There are two technologies that can deliver dynamic proxies: dynamic code generation (using <em>System.Reflection.Emit</em>, typically), and remoting proxies (see <a title="RealProxy in MSDN Documentation" href="http://msdn.microsoft.com/en-us/library/system.runtime.remoting.proxies.realproxy.aspx" target="_blank">RealProxy</a><em>).</em></p>
<p>Please read <a href="http://msdn.microsoft.com/en-us/magazine/gg490353.aspx" target="_blank">Dino Esposito&rsquo;s article</a> in MSDN Magazine for details about dynamic proxies.&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2>Proxy-Based AOP: The Good</h2>
<p>What I love about the proxy-based approach is how AOP blends into the DI concept. DI lets you configure how the container should build the components by injecting dependencies, setting properties and calling initialization methods &ndash; you can also inject aspects at the interface of components. You can configure aspects just as other dependencies in an XML file or using C# code, just as if the issue of building and assembling components were unified.</p>
<p>The ability to add aspects just by changing a configuration file may prove very useful in production. Suppose there&rsquo;s some issue somewhere and you want to trace all accesses to a specific component. You can do that without recompiling the application. This may be a decisive advantage in formal environments, where it can take months to go from a bug report to the deployment of a fix.</p>
<h2>Proxy-Based AOP: The Bad</h2>
<p>Proxy-based AOP, as implemented by DI frameworks, has serious limitations:</p>
<ul>
<li>It only works on the surface of components, exposed as an interface. It does not work for all methods that are internal to the component, whether public or private, static or instance. Remember that a component is an <em>application part</em>, and generally includes several classes.</li>
<li>It only works when the client code got a reference of the component from the container. Aspects will not be applied if the component invokes itself, or if the component is invoked without the intermediary of the container. This can be seriously misleading!</li>
<li>Since aspects are applied at runtime, there is no possibility for build-time verification. Build-time AOP frameworks such as PostSharp will emit compilation errors if the aspect is used incorrectly, and will even provide the aspect developer with different ways to verify, at build time, that the aspect has been used in a meaningful way (for instance, don&rsquo;t add a caching aspect to a method that returns a stream, or to a method that already has a security aspect).</li>
<li>It is difficult to figure out (a) which aspects are applied to the piece of code you&rsquo;re working on and (b) to which pieces of code the aspect you&rsquo;re working on has been applied. Full frameworks such as PostSharp or AspectJ can display this information inside the IDE, substantially improving the understandability of source code.</li>
<li>Run-time AOP has higher runtime overhead than build-time frameworks. This may be of minor importance if you only apply aspects to coarsely-grained components, but just generating dynamic proxies has a significant cost if you have hundreds of classes.</li>
<li>Dynamic proxies are always a side feature of dependency injection framework and do not implement the full vision, even when technically feasible. They are mostly limited to method interception, which hardly compares to what AspectJ and PostSharp have to offer.</li>
</ul>
<h2>Proxy-Based AOP: The Ugly</h2>
<p>There&rsquo;s always a risk when a practice becomes mainstream: it starts being used <em>just for the sake of itself</em>, because it makes you feel safe. This is when a practice becomes a dogma.</p>
<p>It clearly happened to test-driven development, which suddenly imposed upon the community to write tests at meaningless levels of granularity. And thus so with dependency injection, which tends to be used to isolate <em>classes </em>from each other. Remember that dependency injection had been initially proposed to isolate <em>components</em>, i.e. parts of applications of rather coarse granularity. I am concerned that we are &lsquo;forced&rsquo; (by social pressure) to write more complex applications just to meet testing &lsquo;requirements&rsquo; that do not result in higher quality. Remember that unit testing is an instrument, not an objective. The ultimate objective is quality of your application during its whole lifetime.</p>
<p>Don&rsquo;t get me wrong, I am not suggesting that you should not write unit tests. I am concerned that religiously following a practice may actually <em>degrade</em> the quality of your code.</p>
<p>The same issue exists with proxy-based AOP. If DI frameworks made you excited for the power of AOP, you may be tempted to restructure your code just to use more of this proxy-based stuff. <strong>Don&rsquo;t</strong>. Adding aspects to the surface of components using proxies is simple and elegant. If you are making your code DI-friendly just because you need aspects, you are probably doing something wrong. The principal mantra of AOP is that you should <em>not</em> change your base code. If you are, you should probably look at a real AOP framework such as PostSharp or AspectJ.</p>
<h2>Conclusion</h2>
<p>Aspect-Oriented Programming and Dependency Injection are very different concepts, but there are limited cases where they fit well together. In these situations, using the AOP facility of a DI framework makes perfect sense. For other cases you have two options: <em>abuse</em> from dynamic proxies (a non-solution), or use of a dedicated AOP framework.</p>
<p>This is not just me, not just PostSharp, and not just .NET. The same dilemma hangs over Java programmers, who have to <a href="http://www.infoq.com/news/2009/01/ramnivas-aop-choices" target="_blank">choose between the proxy-based Spring AOP and the build-time AspectJ</a> (read the summary of&nbsp; <a href="http://www.infoq.com/news/2009/01/ramnivas-aop-choices">Ramnivas Laddad </a>&lsquo;s talk on this topic).</p>
<p>AOP and DI are not competing technologies. You can use both in the same project. What&rsquo;s important is to understand what each technology was designed for, and to focus on the quality of your code.</p>
<p>Happy PostSharping!</p>
<p>-gael</p>
